import type { Residue } from '../stores/useProteinStore';
import { AMINO_ACIDS } from '../data/aminoAcids';

// Standard C-alpha distance (in Angstroms)
const CA_DISTANCE = 3.8;
const DISTANCE_TOLERANCE = 0.5; // Allow +/- 0.5 Angstroms

interface SanitizationResult {
    pdbString: string;
    warnings: string[];
    isValid: boolean;
}

// Get full amino acid name from 3-letter code
function getFullResidueName(code: string): string {
    const aa = AMINO_ACIDS.find(a => a.code === code);
    return aa?.code ?? 'GLY'; // Default to Glycine
}

// Pad string for PDB format (right-justified)
function padRight(str: string, length: number): string {
    return str.padEnd(length, ' ');
}

// Pad number for PDB format (left-justified with spaces)
function padLeft(str: string, length: number): string {
    return str.padStart(length, ' ');
}

// Format coordinate for PDB (8 characters, 3 decimal places)
function formatCoord(value: number): string {
    return value.toFixed(3).padStart(8, ' ');
}

/**
 * Sanitize residue positions to ensure biologically plausible distances
 */
function sanitizeResidues(residues: Residue[]): { sanitized: Residue[]; warnings: string[] } {
    const warnings: string[] = [];

    if (residues.length < 2) {
        return { sanitized: residues, warnings };
    }

    const sanitized: Residue[] = [{ ...residues[0] }];

    for (let i = 1; i < residues.length; i++) {
        const prev = sanitized[i - 1];
        const curr = { ...residues[i] };

        // Calculate distance
        const dx = curr.position[0] - prev.position[0];
        const dy = curr.position[1] - prev.position[1];
        const dz = curr.position[2] - prev.position[2];
        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

        // Check if distance is within acceptable range
        if (Math.abs(distance - CA_DISTANCE) > DISTANCE_TOLERANCE) {
            warnings.push(`Residue ${i + 1}: Distance adjusted from ${distance.toFixed(2)}Å to ${CA_DISTANCE}Å`);

            // Normalize and scale to correct distance
            if (distance > 0) {
                const scale = CA_DISTANCE / distance;
                curr.position = [
                    prev.position[0] + dx * scale,
                    prev.position[1] + dy * scale,
                    prev.position[2] + dz * scale,
                ];
            } else {
                // If distance is 0, place along X axis
                curr.position = [
                    prev.position[0] + CA_DISTANCE,
                    prev.position[1],
                    prev.position[2],
                ];
            }
        }

        sanitized.push(curr);
    }

    return { sanitized, warnings };
}

/**
 * Export residues to PDB format string
 */
export function exportToPDB(residues: Residue[]): SanitizationResult {
    if (residues.length === 0) {
        return {
            pdbString: '',
            warnings: ['No residues to export'],
            isValid: false,
        };
    }

    // Sanitize positions
    const { sanitized, warnings } = sanitizeResidues(residues);

    const lines: string[] = [];

    // Header
    lines.push('HEADER    PROTEIN BUILDER EXPORT');
    lines.push(`TITLE     USER-BUILT PROTEIN STRUCTURE`);
    lines.push(`REMARK   1 GENERATED BY PROTEIN PLAYGROUND`);
    lines.push(`REMARK   2 ${sanitized.length} RESIDUES`);

    // ATOM records (C-alpha only for backbone trace)
    for (let i = 0; i < sanitized.length; i++) {
        const residue = sanitized[i];
        const resName = getFullResidueName(residue.type).toUpperCase();
        const atomNum = i + 1;
        const resNum = i + 1;
        const [x, y, z] = residue.position;

        // PDB ATOM record format:
        // ATOM      1  CA  GLY A   1       0.000   0.000   0.000  1.00  0.00           C
        // Columns: 1-6=ATOM, 7-11=serial, 13-16=atom name, 17=alt loc, 18-20=res name,
        //          22=chain, 23-26=res seq, 27=iCode, 31-38/39-46/47-54=x/y/z, 55-60=occ,
        //          61-66=temp, 77-78=element, 79-80=charge

        let line = 'ATOM  ';
        line += padLeft(atomNum.toString(), 5);        // 7-11: Atom serial number
        line += '  CA  ';                              // 12-16: Atom name (CA = alpha carbon)
        line += padRight(resName.substring(0, 3), 3);  // 17-20: Residue name (truncate to 3)
        line += ' A';                                  // 21-22: Chain identifier
        line += padLeft(resNum.toString(), 4);         // 23-26: Residue sequence number
        line += '    ';                                // 27-30: iCode + spacing
        line += formatCoord(x);                        // 31-38: X coordinate
        line += formatCoord(y);                        // 39-46: Y coordinate
        line += formatCoord(z);                        // 47-54: Z coordinate
        line += '  1.00';                              // 55-60: Occupancy
        line += '  0.00';                              // 61-66: Temperature factor
        line += '           C';                        // 67-78: Element + spacing

        lines.push(line);
    }

    // TER record
    lines.push(`TER   ${padLeft((sanitized.length + 1).toString(), 5)}      ${getFullResidueName(sanitized[sanitized.length - 1].type).toUpperCase()} A${padLeft(sanitized.length.toString(), 4)}`);

    // END record
    lines.push('END');

    return {
        pdbString: lines.join('\n'),
        warnings,
        isValid: true,
    };
}

/**
 * Parse a PDB file and extract residue positions
 */
export function parsePDBToResidues(pdbString: string): Residue[] {
    const lines = pdbString.split('\n');
    const residues: Residue[] = [];
    const seenResidues = new Set<string>();

    for (const line of lines) {
        if (!line.startsWith('ATOM')) continue;

        // Only process CA (alpha carbon) atoms for backbone
        const atomName = line.substring(12, 16).trim();
        if (atomName !== 'CA') continue;

        const resName = line.substring(17, 20).trim();
        const chain = line.substring(21, 22);
        const resSeq = line.substring(22, 26).trim();

        // Skip duplicate residues
        const resKey = `${chain}${resSeq}`;
        if (seenResidues.has(resKey)) continue;
        seenResidues.add(resKey);

        const x = parseFloat(line.substring(30, 38));
        const y = parseFloat(line.substring(38, 46));
        const z = parseFloat(line.substring(46, 54));

        // Map 3-letter code to our format
        const aminoAcid = AMINO_ACIDS.find(aa => aa.code.toUpperCase() === resName);
        const type = aminoAcid?.code ?? 'Gly';

        residues.push({
            id: `pdb-${resKey}-${Date.now()}`,
            type,
            position: [x, y, z],
            rotation: [0, 0, 0, 1],
            connectedTo: null,
        });
    }

    // Set up connections
    for (let i = 0; i < residues.length - 1; i++) {
        residues[i].connectedTo = residues[i + 1].id;
    }

    return residues;
}
